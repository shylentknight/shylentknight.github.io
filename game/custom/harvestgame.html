<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harvest Clicker (Offline/Online)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <!-- Load Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, Timestamp, collection, query, orderBy, addDoc, limit, getDoc, runTransaction, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variable assignments (needed for the script block below)
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            onAuthStateChanged,
            signOut,
            getFirestore,
            doc,
            setDoc,
            onSnapshot,
            setLogLevel,
            Timestamp,
            collection,
            query,
            orderBy,
            addDoc,
            limit,
            getDoc,
            runTransaction, 
            updateDoc,
            GoogleAuthProvider,
            signInWithPopup,
            deleteDoc
        };
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fee7; /* Light green background */
        }
        .card {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Custom scrollbar for game log */
        #log-container::-webkit-scrollbar,
        #chat-container::-webkit-scrollbar {
            width: 4px;
        }
        #log-container::-webkit-scrollbar-thumb,
        #chat-container::-webkit-scrollbar-thumb {
            background-color: #d1d5db; /* gray-300 */
            border-radius: 2px;
        }
        .farm-plot {
            /* 5-column grid means 20% width */
            @apply flex items-center justify-center text-3xl font-bold rounded-lg border-2 border-dashed border-gray-300 relative overflow-hidden;
            aspect-ratio: 1 / 1; /* Makes plots square */
        }
        .farm-plot.empty {
            @apply bg-gray-100 text-gray-400 border-gray-200;
        }
        .farm-plot.growing {
            @apply bg-lime-100 text-lime-700 border-lime-400;
        }
        .farm-plot.ready {
            @apply bg-yellow-100 text-yellow-700 border-yellow-400;
        }
        .plot-timer {
            @apply absolute bottom-1 right-1 text-xs font-semibold px-1 rounded bg-black bg-opacity-30 text-white;
        }
        /* Desktop specific height for chat/log area balance */
        @media (min-width: 1024px) { 
             /* Ensure a minimum height for the chat/log column on desktop */
            .lg-col-fixed-height {
                min-height: 40rem; /* approx 640px */
            }
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex justify-center min-h-screen">

    <div id="app" class="w-full max-w-7xl lg:px-8">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-green-700 tracking-tight">Harvest Clicker üöú</h1>
            <p class="text-sm text-green-500 mt-1">Sow, wait, and automate.</p>
        </header>

        <!-- Main Content Grid: Single column on mobile, three columns on large screens -->
        <div class="lg:grid lg:grid-cols-3 lg:gap-8 xl:gap-12">

            <!-- ========================================================================= -->
            <!-- LEFT & MIDDLE COLUMNS: CORE GAME ELEMENTS (Spans 2/3 of desktop width) -->
            <!-- ========================================================================= -->
            <div class="lg:col-span-2 space-y-6">
                
                <!-- Row 1: Top Bar (Money, Auth, Mode Switch) - 1 or 2 columns based on screen size -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Money Display -->
                    <div class="card bg-yellow-100 p-4 rounded-xl flex justify-between items-center shadow-lg border-2 border-yellow-500">
                        <span class="text-xl font-bold text-yellow-800 flex items-center">
                            üí∞ <span class="ml-2">Money:</span> <span id="money-display" class="ml-2 text-2xl">0</span>
                        </span>
                    </div>

                    <!-- Auth Status/Action -->
                    <div class="card bg-white p-3 rounded-xl flex flex-col justify-center items-center shadow-md border-2 border-gray-300">
                        <div class="text-xs text-gray-500 mb-1" id="user-id-display">Loading User...</div>
                        <button id="auth-button" onclick="handleAuthAction()" class="w-full px-3 py-1 text-xs font-semibold rounded-lg transition bg-blue-500 hover:bg-blue-600 text-white">
                            Loading...
                        </button>
                    </div>

                    <!-- New Mode Switch -->
                    <div class="card bg-white p-3 rounded-xl flex flex-col justify-center items-center shadow-md border-2 border-gray-300">
                        <div class="text-xs text-gray-500 mb-1" id="mode-status-display">Mode: Local Save</div>
                        <button id="mode-switch-button" onclick="handleModeSwitch()" class="w-full px-3 py-1 text-xs font-semibold rounded-lg transition bg-purple-500 hover:bg-purple-600 text-white disabled:bg-gray-400">
                            Mode: Local üè†
                        </button>
                    </div>

                </div>
                
                <!-- Row 2: Profile & Actions/Upgrades - 1 column on mobile, 2 columns on medium/large screens -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    
                    <!-- User Profile/Username Section (Left 1/3 of desktop layout) -->
                    <section class="mb-0">
                        <h2 class="text-xl font-bold text-green-700 mb-3">User Profile</h2>
                        <div class="flex card bg-white p-4 rounded-xl shadow-md border-2 border-gray-300">
                            <input type="text" id="username-input" placeholder="Enter your unique username" class="flex-grow p-2 border border-gray-300 rounded-l-lg focus:ring-green-500 focus:border-green-500 disabled:bg-gray-100" maxlength="20">
                            <button id="set-username-btn" onclick="updateUsername()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-r-lg transition disabled:bg-gray-400">Set Username</button>
                        </div>
                        <p id="username-status" class="text-xs mt-2 text-gray-500 text-center">Your current display name is: <span id="current-display-name">Loading...</span></p>
                        
                        <h2 class="text-xl font-bold text-green-700 mb-3 mt-6">Actions</h2>
                        <div class="grid grid-cols-3 gap-3">
                            <button id="plant-btn" onclick="plant()" class="flex flex-col items-center justify-center p-3 rounded-xl bg-lime-600 hover:bg-lime-700 text-white font-bold transition duration-150 transform hover:scale-105 active:scale-95 disabled:opacity-50 h-24">
                                <span class="text-2xl">‚ûï</span>
                                <span>Plant (1 Seed)</span>
                            </button>
                            <button id="water-btn" onclick="water()" class="flex flex-col items-center justify-center p-3 rounded-xl bg-blue-600 hover:bg-blue-700 text-white font-bold transition duration-150 transform hover:scale-105 active:scale-95 disabled:opacity-50 h-24">
                                <span class="text-2xl">üíß</span>
                                <span>Refill Water</span>
                            </button>
                            <button id="harvest-btn" onclick="harvest()" class="flex flex-col items-center justify-center p-3 rounded-xl bg-yellow-600 hover:bg-yellow-700 text-white font-bold transition duration-150 transform hover:scale-105 active:scale-95 disabled:opacity-50 h-24">
                                <span class="text-2xl">ü•ï</span>
                                <span>Harvest</span>
                            </button>
                        </div>
                    </section>

                    <!-- Upgrades Section (Left 1/3 of desktop layout) -->
                    <div class="space-y-6">
                        <!-- Upgrades Section -->
                        <section class="mb-0">
                            <h2 class="text-xl font-bold text-green-700 mb-3">Upgrades</h2>
                            <div id="upgrades-container" class="space-y-3">
                                <!-- Upgrades dynamically generated here -->
                            </div>
                        </section>
                    </div>
                </div>

                <!-- Row 3: Farm Plots Visual Section (Middle 1/3 of desktop layout) -->
                <section class="mb-0">
                    <h2 class="text-xl font-bold text-green-700 mb-3">Your Farm (<span id="plots-count-display">0</span>/<span id="plot-capacity-display-farm">0</span> plots)</h2>
                    <!-- Scrollable container for the farm plots -->
                    <div id="farm-plots-container" class="grid grid-cols-5 gap-2 p-3 bg-green-200 rounded-xl border-2 border-green-500 lg:h-96 overflow-y-auto">
                        <!-- Plots dynamically generated here -->
                    </div>
                    <div class="mt-4 card bg-green-50 p-3 rounded-xl text-sm text-green-800 text-center">
                        Inventory: <span id="seeds-display" class="font-medium">0</span> Seeds
                    </div>
                </section>
            </div>

            <!-- ========================================================================= -->
            <!-- RIGHT COLUMN: LOG & CHAT (Spans 1/3 of desktop width) -->
            <!-- ========================================================================= -->
            <div class="lg:col-span-1 space-y-6 mt-6 lg:mt-0 lg-col-fixed-height flex flex-col">

                <!-- Game Log -->
                <section class="flex-1 min-h-[10rem] max-h-[12rem] lg:max-h-none lg:flex-grow">
                    <h2 class="text-xl font-bold text-green-700 mb-3">Game Log</h2>
                    <div id="log-container" class="card bg-gray-100 p-3 rounded-xl h-full overflow-y-auto text-sm space-y-1 shadow-md border-2 border-gray-300">
                        <div class="text-gray-600">Game started. Initializing persistence...</div>
                    </div>
                </section>

                <!-- Chat Section -->
                <section class="flex-1 flex flex-col min-h-[16rem] lg:min-h-[20rem] lg:flex-grow">
                    <h2 class="text-xl font-bold text-green-700 mb-3">Global Farm Chat üí¨</h2>
                    <div id="chat-container" class="card bg-gray-100 p-3 rounded-xl flex-1 overflow-y-auto flex flex-col-reverse shadow-md border-2 border-gray-300">
                        <!-- Messages will be prepended here -->
                        <div class="text-gray-400 text-center text-sm">Welcome to the Global Chat!</div>
                    </div>
                    <div class="flex mt-3">
                        <input type="text" id="chat-input" placeholder="Type a message..." class="flex-grow p-2 border border-gray-300 rounded-l-xl focus:ring-green-500 focus:border-green-500">
                        <button onclick="handleSendMessage()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-r-xl transition">Send</button>
                    </div>
                </section>
            </div>
        </div>


        <!-- Floating Message Modal -->
        <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden justify-center items-center p-4 z-50 transition-opacity duration-300 opacity-0">
            <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full text-center">
                <!-- Modal content will be dynamically updated for simple message or confirmation -->
                <p id="modal-text" class="text-lg font-semibold text-gray-800 mb-4"></p>
                <button onclick="closeModal()" class="w-full bg-green-600 text-white py-2 rounded-lg hover:bg-green-700 transition">OK</button>
            </div>
        </div>
    </div>

    <script>
        // Setup a mock config for running locally outside the Canvas environment.
        const MOCK_FIREBASE_CONFIG = {
            apiKey: "YOUR_API_KEY_HERE", 
            authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_PROJECT_ID.appspot.com",
            messagingSenderId: "YOUR_SENDER_ID",
            appId: "YOUR_APP_ID"
        };

        // --- Persistence and State Variables ---
        const LOCAL_STORAGE_KEY = 'harvestClicker_offlineSave';
        let currentMode = 'local'; // 'local' or 'online'
        let firestoreUnsubscribe = null;
        
        // --- Firebase Configuration and Initialization ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : MOCK_FIREBASE_CONFIG;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db;
        let auth;
        let userId = '';
        let displayUserId = ''; 
        let isAuthReady = false;
        
        // Firestore constants
        const GAME_COLLECTION = 'game_state';
        const CHAT_COLLECTION = 'chat_messages';
        const GAME_DOC_ID = 'farm_clicker_v5'; 
        const USER_PROFILE_COLLECTION = 'user_profile';
        const USER_PROFILE_DOC_ID = 'data';
        const USERNAMES_COLLECTION = 'usernames_map'; 

        // Game Constants
        const GROWTH_TIME_SECONDS = 10;
        const WATER_REFILL_COST = 5;
        const MAX_PLOT_CAPACITY = 100;
        const USERNAME_COOLDOWN_SECONDS = 86400; // 24 hours

        // Set up game state defaults
        let gameState = {
            money: 10.00,
            seeds: 5,
            plots: [],
            plotCapacity: 1, 
            harvestMultiplier: 1.0,
            autoPlantLevel: 0,
            autoHarvestLevel: 0,
            lastPlayed: Date.now(),
            isReady: false,
            lastUsernameChange: 0, 
        };

        const UPGRADES = {
            plot_cap: {
                name: "Expand Farmland",
                baseCost: 20,
                costMultiplier: 1.5,
                effect: "Increases farm plot capacity by 1.",
                apply: (state) => { state.plotCapacity += 1; }
            },
            harvest_multi: {
                name: "Better Seeds",
                baseCost: 50,
                costMultiplier: 2.0,
                effect: "Increases harvest yield multiplier by 0.1.",
                apply: (state) => { state.harvestMultiplier += 0.1; }
            },
            auto_plant: {
                name: "Auto Planter",
                baseCost: 100,
                costMultiplier: 3.0,
                effect: "Automatically plants 1 plot every 5 seconds per level, if seeds and space are available.",
                apply: (state) => { state.autoPlantLevel += 1; }
            },
            auto_harvest: {
                name: "Auto Harvester",
                baseCost: 150,
                costMultiplier: 3.5,
                effect: "Automatically harvests 1 ready plot every 5 seconds per level.",
                apply: (state) => { state.autoHarvestLevel += 1; }
            }
        };
        
        function getUpgradeCost(key) {
            const up = UPGRADES[key];
            const currentLevel = gameState[key] || 0;
            return Math.floor(up.baseCost * Math.pow(up.costMultiplier, currentLevel));
        }
        
        // --- Firebase Document References ---
        function getGameDocRef() {
            if (!db || !userId) return null;
            return firebase.doc(db, 'artifacts', appId, 'users', userId, GAME_COLLECTION, GAME_DOC_ID);
        }

        function getProfileDocRef() {
            if (!db || !userId) return null;
            return firebase.doc(db, 'artifacts', appId, 'users', userId, USER_PROFILE_COLLECTION, USER_PROFILE_DOC_ID);
        }

        function getChatCollectionRef() {
            if (!db) return null;
            return firebase.collection(db, 'artifacts', appId, 'public', 'data', CHAT_COLLECTION);
        }
        
        function getUsernamesCollectionRef() {
            if (!db) return null;
            return firebase.collection(db, 'artifacts', appId, 'public', 'data', USERNAMES_COLLECTION);
        }

        // --- Core Utility Functions ---
        function log(message, type = 'info') {
            const logContainer = document.getElementById('log-container');
            const logEntry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            let color = 'text-gray-600';

            if (type === 'error') color = 'text-red-500 font-semibold';
            if (type === 'success') color = 'text-green-600';
            if (type === 'purchase') color = 'text-purple-600';
            if (type === 'tick') color = 'text-blue-600';

            logEntry.className = color;
            logEntry.innerHTML = `[${timestamp}] ${message}`;

            if (logContainer.firstChild) {
                logContainer.insertBefore(logEntry, logContainer.firstChild);
            } else {
                logContainer.appendChild(logEntry);
            }

            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        function growPlots(state, now) {
            let maturedCount = 0;
            const maturityTime = GROWTH_TIME_SECONDS * 1000;

            state.plots.forEach(plot => {
                if (!plot.isReady && (now - plot.plantedAt) >= maturityTime) {
                    plot.isReady = true;
                    maturedCount++;
                }
            });
            return maturedCount;
        }

        function applyOfflineProgress(state) {
            const now = Date.now();
            const lastTime = state.lastPlayed; 
            const timeDiffSeconds = Math.floor((now - lastTime) / 1000);

            if (timeDiffSeconds > 5) {
                let harvestedFromAuto = 0;
                let plantedByAuto = 0; 
                
                // 1. Process Growth
                state.plots.forEach(plot => {
                    if (!plot.isReady && (now - plot.plantedAt) >= GROWTH_TIME_SECONDS * 1000) {
                        plot.isReady = true;
                    }
                });
                
                // 2. Process Auto-Harvest
                if (state.autoHarvestLevel > 0) {
                    const autoHarvestRate = 5; 
                    const potentialHarvests = Math.floor((timeDiffSeconds * state.autoHarvestLevel) / autoHarvestRate);

                    const readyPlots = state.plots.filter(p => p.isReady).sort((a,b) => a.plantedAt - b.plantedAt);
                    harvestedFromAuto = Math.min(potentialHarvests, readyPlots.length);

                    if (harvestedFromAuto > 0) {
                        for (let i = 0; i < harvestedFromAuto; i++) {
                            const plotToHarvest = readyPlots[i];
                            const indexToRemove = state.plots.findIndex(p => p.id === plotToHarvest.id);
                            if (indexToRemove !== -1) {
                                state.plots.splice(indexToRemove, 1);
                            }
                        }
                    }
                }

                const moneyGained = harvestedFromAuto * (1.0 * state.harvestMultiplier);
                state.money += moneyGained;
                
                // 3. Process Auto-Plant (less critical for offline since growth already happened, but for consistency)
                if (state.autoPlantLevel > 0 && state.seeds > 0) {
                    const autoPlantRate = 5;
                    const potentialPlants = Math.floor((timeDiffSeconds * state.autoPlantLevel) / autoPlantRate);
                    const availableSlots = state.plotCapacity - state.plots.length;
                    plantedByAuto = Math.min(potentialPlants, availableSlots, state.seeds);

                    for (let i = 0; i < plantedByAuto; i++) {
                        state.seeds--;
                        state.plots.push({ id: Math.random().toString(36).substring(2, 9), plantedAt: now, isReady: false });
                    }
                }

                if (moneyGained > 0 || plantedByAuto > 0) {
                    log(`While you were away for ${timeDiffSeconds}s: Gained $${moneyGained.toFixed(2)} from ${harvestedFromAuto} auto-harvests. Planted ${plantedByAuto} plots.`, 'success');
                } else if (timeDiffSeconds > 60) {
                    log(`You were away for ${Math.floor(timeDiffSeconds / 60)} minutes. Check the log for any maturing plots!`);
                }
            }
            state.lastPlayed = now;
        }

        // --- Save/Load Functions for Local Storage ---
        function loadLocalGame() {
            const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (saved) {
                try {
                    let loadedState = JSON.parse(saved);
                    // Ensure numbers are numbers and apply progress
                    ['money', 'seeds', 'plotCapacity', 'harvestMultiplier', 'autoPlantLevel', 'autoHarvestLevel'].forEach(key => {
                        loadedState[key] = parseFloat(loadedState[key] || 0);
                    });
                    
                    if (!Array.isArray(loadedState.plots)) loadedState.plots = [];
                    loadedState.plots.forEach(p => {
                         // lastPlayed is already a number from JSON.parse
                        p.plantedAt = p.plantedAt || Date.now();
                        p.isReady = p.isReady || false;
                    });

                    applyOfflineProgress(loadedState);
                    log('Loaded game state from Local Storage.', 'success');
                    return { ...gameState, ...loadedState, isReady: true };
                } catch (e) {
                    log(`Error parsing local save: ${e.message}. Starting new local game.`, 'error');
                }
            }
            log('No local save found. Starting new game in Local Mode.');
            return { ...gameState, isReady: true }; // Start with default settings
        }

        function saveLocalGame() {
            try {
                const dataToSave = { ...gameState };
                dataToSave.plots = gameState.plots.map(p => ({
                    id: p.id,
                    plantedAt: p.plantedAt,
                    isReady: p.isReady
                }));
                
                // Remove transient states
                delete dataToSave.lastUsernameChange;
                delete dataToSave.isReady;
                
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            } catch (e) {
                log(`Error saving game to Local Storage: ${e.message}`, 'error');
            }
        }

        // --- Save/Load Functions for Firestore ---
        async function loadOnlineGame() {
            const ref = getGameDocRef();
            if (!ref) return null;
            
            try {
                const docSnap = await firebase.getDoc(ref);
                if (docSnap.exists()) {
                    let loadedState = docSnap.data();
                    
                    // Convert Firestore Timestamps to JS numbers for consistency
                    if (loadedState.plots) {
                        loadedState.plots = loadedState.plots.map(p => ({
                            id: p.id,
                            plantedAt: p.plantedAt.toMillis ? p.plantedAt.toMillis() : p.plantedAt,
                            isReady: p.isReady
                        }));
                    }
                    if (loadedState.lastPlayed && loadedState.lastPlayed.toMillis) {
                         loadedState.lastPlayed = loadedState.lastPlayed.toMillis();
                    }

                    // Apply types and progress
                    ['money', 'seeds', 'plotCapacity', 'harvestMultiplier', 'autoPlantLevel', 'autoHarvestLevel'].forEach(key => {
                        loadedState[key] = parseFloat(loadedState[key] || 0);
                    });
                    
                    applyOfflineProgress(loadedState);
                    log('Loaded game state from Cloud (one-time fetch).', 'success');
                    return { ...gameState, ...loadedState, isReady: true };
                }
            } catch (e) {
                log(`Error loading game from Cloud: ${e.message}`, 'error');
            }
            return null; // Indicates no cloud save found or error
        }

        async function saveGame(state) {
            if (currentMode === 'local') {
                saveLocalGame();
            } else if (currentMode === 'online') {
                const ref = getGameDocRef();
                if (ref) {
                    try {
                        const dataToSave = {
                            ...state,
                            plots: state.plots.map(p => ({
                                id: p.id,
                                plantedAt: p.plantedAt,
                                isReady: p.isReady
                            })),
                            lastPlayed: firebase.Timestamp.now()
                        };

                        // Clean up properties not meant for persistence
                        delete dataToSave.lastUsernameChange;
                        delete dataToSave.isReady;

                        await firebase.setDoc(ref, dataToSave);
                    } catch (e) {
                        log(`Error saving game to Cloud: ${e.message}`, 'error');
                    }
                }
            }
        }

        // --- Firebase Listener Management ---
        function startOnlineListener() {
            if (firestoreUnsubscribe) return; // Already listening

            const ref = getGameDocRef();
            if (!ref) return;

            firestoreUnsubscribe = firebase.onSnapshot(ref, (docSnap) => {
                if (currentMode !== 'online') return; 

                let loadedState = null;
                if (docSnap.exists()) {
                    loadedState = docSnap.data();
                }

                if (loadedState) {
                    // Merge loaded state, ensuring plots are correctly formatted
                    gameState = { ...gameState, ...loadedState };

                    if (!Array.isArray(gameState.plots)) gameState.plots = [];
                    gameState.plots = gameState.plots.map(p => ({
                        id: p.id || Math.random().toString(36).substring(2, 9),
                        plantedAt: p.plantedAt.toMillis ? p.plantedAt.toMillis() : p.plantedAt,
                        isReady: p.isReady
                    }));
                    
                    if (gameState.lastPlayed && gameState.lastPlayed.toMillis) {
                        gameState.lastPlayed = gameState.lastPlayed.toMillis();
                    }

                    ['money', 'seeds', 'plotCapacity', 'harvestMultiplier', 'autoPlantLevel', 'autoHarvestLevel'].forEach(key => {
                        gameState[key] = parseFloat(gameState[key] || 0);
                    });

                    applyOfflineProgress(gameState);
                    log('Cloud state synchronized.', 'info');

                } else if (docSnap.exists === false) {
                    // If cloud doc doesn't exist, create it from current state
                    log('No Cloud save found for this user. Uploading current progress.', 'info');
                    saveGame(gameState);
                }
                gameState.isReady = true;
                renderGame();
            }, (error) => {
                log(`Error fetching game state: ${error.message}`, 'error');
            });
        }

        function stopOnlineListener() {
            if (firestoreUnsubscribe) {
                firestoreUnsubscribe();
                firestoreUnsubscribe = null;
                log('Stopped Cloud synchronization listener.', 'info');
            }
        }

        // --- Mode Switch Logic ---
        window.handleModeSwitch = async function() {
            const modeButton = document.getElementById('mode-switch-button');
            const modeStatus = document.getElementById('mode-status-display');
            modeButton.disabled = true;

            if (!userId) {
                showModal('You must be signed in to switch to Online Mode.');
                modeButton.disabled = false;
                return;
            }
            if (!gameState.isReady) {
                showModal('Game state not yet loaded. Please wait a moment.');
                modeButton.disabled = false;
                return;
            }
            
            // 1. Save current state before switching
            saveGame(gameState);
            
            // Determine new mode
            const newMode = currentMode === 'local' ? 'online' : 'local';

            if (newMode === 'online') {
                // Switching to ONLINE: Load Cloud save and prompt for conflict resolution
                log('Switching to Online Mode...', 'tick');
                const cloudState = await loadOnlineGame();
                
                if (cloudState) {
                    // Conflict Resolution Prompt
                    showModalConfirm(
                        'Cloud Save Found!',
                        'Do you want to load your Cloud progress, or keep your current Local progress and use it as your new Cloud save?',
                        async () => { // Confirm: Load Cloud
                            gameState = { ...gameState, ...cloudState };
                            log('Loaded Cloud save and starting online sync.', 'success');
                            currentMode = 'online';
                            startOnlineListener();
                            renderGame();
                            modeButton.textContent = 'Mode: Online ‚òÅÔ∏è';
                            modeStatus.textContent = 'Mode: Online Cloud Save';
                        },
                        async () => { // Cancel: Overwrite Cloud with Local
                            log('Continuing with Local save and overwriting Cloud save.', 'info');
                            currentMode = 'online';
                            startOnlineListener(); 
                            saveGame(gameState); // Force save of current state to cloud
                            renderGame();
                            modeButton.textContent = 'Mode: Online ‚òÅÔ∏è';
                            modeStatus.textContent = 'Mode: Online Cloud Save';
                        }
                    );
                } else {
                    // No cloud save found, switch and save current state to cloud
                    log('No Cloud save found. Switching to Online Mode and saving current progress.', 'info');
                    currentMode = 'online';
                    startOnlineListener();
                    saveGame(gameState); 
                    renderGame();
                    modeButton.textContent = 'Mode: Online ‚òÅÔ∏è';
                    modeStatus.textContent = 'Mode: Online Cloud Save';
                }

            } else {
                // Switching to OFFLINE: Stop listener and prompt for conflict resolution
                log('Switching to Local Mode...', 'tick');
                stopOnlineListener();
                
                const localState = loadLocalGame();
                
                // Conflict Resolution Prompt
                showModalConfirm(
                    'Local Save Found!',
                    'Do you want to load your Local progress, or continue with your current Cloud progress and save it locally?',
                    async () => { // Confirm: Load Local
                        gameState = { ...gameState, ...localState };
                        log('Loaded Local save.', 'success');
                        currentMode = 'local';
                        renderGame();
                        modeButton.textContent = 'Mode: Local üè†';
                        modeStatus.textContent = 'Mode: Local Browser Save';
                    },
                    async () => { // Cancel: Save Online to Local
                        log('Continuing with Cloud save and saving it locally.', 'info');
                        currentMode = 'local';
                        saveGame(gameState); // Force save of current cloud state to local
                        renderGame();
                        modeButton.textContent = 'Mode: Local üè†';
                        modeStatus.textContent = 'Mode: Local Browser Save';
                    }
                );
            }
            modeButton.disabled = false;
        }

        // --- Modal/UI Helpers (Updated for Confirmation) ---
        function showModal(message) {
            const modal = document.getElementById('message-modal');
            const contentDiv = modal.querySelector('.bg-white');
            
            // Restore simple OK button structure
            contentDiv.innerHTML = `
                <p id="modal-text" class="text-lg font-semibold text-gray-800 mb-4">${message}</p>
                <button onclick="closeModal()" class="w-full bg-green-600 text-white py-2 rounded-lg hover:bg-green-700 transition">OK</button>
            `;

            modal.classList.remove('hidden', 'opacity-0');
            modal.classList.add('flex', 'opacity-100');
        }

        let modalConfirmCallback = null;

        function showModalConfirm(title, message, confirmCallback, cancelCallback) {
            const modal = document.getElementById('message-modal');
            const contentDiv = modal.querySelector('.bg-white');
            
            contentDiv.innerHTML = `
                <p id="modal-text" class="text-lg font-semibold text-gray-800 mb-4">
                    <h3 class="text-xl font-bold text-gray-900 mb-2">${title}</h3>
                    <p class="text-gray-700">${message}</p>
                </p>
            `;
            
            // Create custom button layout
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'flex flex-col space-y-3 sm:flex-row sm:space-y-0 sm:space-x-3 mt-4';
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'w-full bg-green-600 text-white py-2 rounded-lg hover:bg-green-700 transition font-semibold';
            confirmBtn.textContent = 'Confirm Action';
            confirmBtn.onclick = () => { confirmCallback(); closeModal(); };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'w-full bg-gray-300 text-gray-800 py-2 rounded-lg hover:bg-gray-400 transition font-semibold';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => { cancelCallback(); closeModal(); };

            buttonContainer.appendChild(confirmBtn);
            buttonContainer.appendChild(cancelBtn);
            contentDiv.appendChild(buttonContainer);

            modal.classList.remove('hidden', 'opacity-0');
            modal.classList.add('flex', 'opacity-100');
        }

        window.closeModal = function() {
            const modal = document.getElementById('message-modal');
            modal.classList.remove('flex', 'opacity-100');
            modal.classList.add('hidden', 'opacity-0');
            
            // Restore the simple OK button structure for next non-confirm call
            const contentDiv = modal.querySelector('.bg-white');
            contentDiv.innerHTML = `
                <p id="modal-text" class="text-lg font-semibold text-gray-800 mb-4"></p>
                <button onclick="closeModal()" class="w-full bg-green-600 text-white py-2 rounded-lg hover:bg-green-700 transition">OK</button>
            `;
        }

        // --- Profile/Username Functions (Modified to rely on currentMode) ---
        
        // ... (fetchAndSetUsername, updateUsernameButtonState, updateUsername functions remain mostly the same, 
        // they rely on the profile doc which is always in Firestore, but they must be disabled if no user is logged in)

        function updateUsernameButtonState() {
            // ... (existing logic)
            const setUsernameBtn = document.getElementById('set-username-btn');
            const usernameStatus = document.getElementById('username-status');
            const now = Date.now();
            
            // Check if user is logged in
            if (!userId) {
                setUsernameBtn.disabled = true;
                setUsernameBtn.textContent = 'Sign In to Set';
                usernameStatus.innerHTML = `Your display name is: <span id="current-display-name">${displayUserId}</span>.`;
                return;
            }

            // ... (rest of cooldown logic)
            const nextChangeTime = gameState.lastUsernameChange + (USERNAME_COOLDOWN_SECONDS * 1000);
            
            if (now < nextChangeTime) {
                // ... (cooldown display logic)
                const remainingSeconds = Math.ceil((nextChangeTime - now) / 1000);
                let timeString = '';
                if (remainingSeconds >= 3600) { 
                    const hours = Math.floor(remainingSeconds / 3600);
                    const minutes = Math.floor((remainingSeconds % 3600) / 60);
                    timeString = `${hours}h ${minutes}m`;
                } else if (remainingSeconds >= 60) {
                    const minutes = Math.floor(remainingSeconds / 60);
                    const seconds = remainingSeconds % 60;
                    timeString = `${minutes}m ${seconds}s`;
                } else {
                    timeString = `${remainingSeconds}s`;
                }

                setUsernameBtn.disabled = true;
                setUsernameBtn.textContent = `Cooldown (${timeString})`;
                
                usernameStatus.innerHTML = `Your current display name is: <span id="current-display-name">${displayUserId}</span>. Change is on cooldown.`;
                setUsernameBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                setUsernameBtn.classList.add('bg-gray-500', 'cursor-not-allowed');

            } else {
                setUsernameBtn.disabled = false;
                setUsernameBtn.textContent = 'Set Username';
                usernameStatus.innerHTML = `Your current display name is: <span id="current-display-name">${displayUserId}</span>.`;
                setUsernameBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                setUsernameBtn.classList.remove('bg-gray-500', 'cursor-not-allowed');
            }
            document.getElementById('current-display-name').textContent = displayUserId;
        }

        async function fetchAndSetUsername(defaultName) {
             const ref = getProfileDocRef();
            let currentUsername = defaultName;
            let lastChangeTimestamp = 0; 

            try {
                const docSnap = await firebase.getDoc(ref);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.username) {
                        currentUsername = data.username;
                    } 
                    if (data.lastUsernameChange && data.lastUsernameChange.toMillis) {
                        lastChangeTimestamp = data.lastUsernameChange.toMillis();
                    }
                }
            } catch (e) {
                log(`Error fetching profile: ${e.message}`, 'error');
            }
            
            displayUserId = currentUsername;
            document.getElementById('user-id-display').textContent = displayUserId;
            
            gameState.lastUsernameChange = lastChangeTimestamp; 
            updateUsernameButtonState();
            document.getElementById('username-input').value = displayUserId.startsWith('User:') ? '' : displayUserId;
        }

        window.updateUsername = async function() {
            const setUsernameBtn = document.getElementById('set-username-btn');
            setUsernameBtn.disabled = true;

            if (!isAuthReady || !userId) {
                showModal('Please sign in to set your username.');
                updateUsernameButtonState();
                return;
            }
            
            const now = Date.now();
            const nextChangeTime = gameState.lastUsernameChange + (USERNAME_COOLDOWN_SECONDS * 1000);

            if (now < nextChangeTime) {
                const remainingSeconds = Math.ceil((nextChangeTime - now) / 1000);
                const hours = Math.floor(remainingSeconds / 3600);
                const minutes = Math.floor((remainingSeconds % 3600) / 60);
                showModal(`Username change is on cooldown! Try again in ${hours} hours and ${minutes} minutes.`);
                updateUsernameButtonState();
                return; 
            }

            const usernameInput = document.getElementById('username-input');
            const requestedUsername = usernameInput.value.trim();
            const normalizedUsername = requestedUsername.toLowerCase();
            const profileRef = getProfileDocRef();
            const currentDisplayName = displayUserId;
            
            if (requestedUsername.length < 3 || requestedUsername.length > 20) {
                showModal('Username must be between 3 and 20 characters long.');
                updateUsernameButtonState();
                return;
            }
            if (!/^[a-zA-Z0-9 _]+$/.test(requestedUsername)) {
                showModal('Username can only contain letters, numbers, spaces, and underscores.');
                updateUsernameButtonState();
                return;
            }
            if (currentDisplayName === requestedUsername) {
                showModal('Your display name is already set to that value.');
                updateUsernameButtonState();
                return;
            }

            try {
                await firebase.runTransaction(db, async (transaction) => {
                    const usernameDocRef = firebase.doc(getUsernamesCollectionRef(), normalizedUsername);
                    const usernameDoc = await transaction.get(usernameDocRef);
                    
                    if (usernameDoc.exists() && usernameDoc.data().userId !== userId) {
                        throw new Error('USERNAME_TAKEN'); 
                    }
                    
                    if (!currentDisplayName.startsWith('User:') && currentDisplayName.toLowerCase() !== normalizedUsername) {
                        const oldUsernameDocRef = firebase.doc(getUsernamesCollectionRef(), currentDisplayName.toLowerCase());
                        transaction.delete(oldUsernameDocRef);
                    }
                    
                    transaction.set(usernameDocRef, { userId: userId, originalCasing: requestedUsername });
                    
                    transaction.set(profileRef, { 
                        username: requestedUsername,
                        lastUsernameChange: firebase.Timestamp.now()
                    });
                });

                log(`Username successfully set to ${requestedUsername}.`, 'success');
                gameState.lastUsernameChange = now; 
                await fetchAndSetUsername(requestedUsername); 
                showModal(`Success! Username updated to: ${requestedUsername}. Cooldown is now active for 24 hours.`);

            } catch (e) {
                if (e.message === 'USERNAME_TAKEN') {
                    showModal(`The username "${requestedUsername}" is already taken by another user. Please choose a different one.`);
                } else {
                    log(`Error saving username (transaction failed): ${e.message}`, 'error');
                    showModal(`Failed to set username due to an unexpected error.`);
                }
            } finally {
                updateUsernameButtonState();
            }
        }
        // --- End Profile/Username Functions ---

        // --- Auth/Startup Functions ---
        function updateAuthButton(user) {
            const button = document.getElementById('auth-button');
            if (user) {
                if (user.isAnonymous) {
                    button.textContent = "Sign in with Google";
                    button.classList.remove('bg-red-500', 'hover:bg-red-600');
                    button.classList.add('bg-blue-500', 'hover:bg-blue-600');
                } else {
                    button.textContent = "Sign Out";
                    button.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                    button.classList.add('bg-red-500', 'hover:bg-red-600');
                }
            } else {
                 button.textContent = "Sign In/Up";
                 button.classList.remove('bg-red-500', 'hover:bg-red-600');
                 button.classList.add('bg-blue-500', 'hover:bg-blue-600');
            }
        }

        window.handleAuthAction = function() {
            if (auth && auth.currentUser && !auth.currentUser.isAnonymous) {
                firebase.signOut(auth);
            } else {
                signInWithGoogle();
            }
        }

        window.signInWithGoogle = function() {
            if (!auth) { showModal('Firebase Auth not ready.'); return; }
            const provider = new firebase.GoogleAuthProvider();
            firebase.signInWithPopup(auth, provider)
                .catch((error) => {
                    log(`Google Sign-In failed: ${error.message}`, 'error');
                    showModal(`Google Sign-In Failed. Error: ${error.code}`);
                });
        }

        function initializeFirebase() {
            if (!firebaseConfig || !firebaseConfig.projectId || firebaseConfig.projectId.includes("YOUR_PROJECT_ID")) {
                log('Firebase config is missing. Game will be local-only.', 'error');
                gameState = loadLocalGame();
                renderGame();
                return;
            }

            try {
                const app = firebase.initializeApp(firebaseConfig);
                db = firebase.getFirestore(app);
                auth = firebase.getAuth(app);

                firebase.onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        
                        const defaultDisplayName = user.displayName || (user.isAnonymous ? `User: ${userId.substring(0, 8)}` : `User: ${userId.substring(0, 8)}`);
                        fetchAndSetUsername(defaultDisplayName);
                        updateAuthButton(user);

                        // If user signs in non-anonymously, automatically attempt to switch to online mode
                        if (!user.isAnonymous) {
                            log('Full account signed in. Starting check for Cloud Save.', 'info');
                            handleModeSwitch(); // This handles save conflict and mode switch
                        } else {
                            // Anonymous or initial load with token: stay local, load local save
                            log('Signed in anonymously/via token. Defaulting to Local Mode. Use switch to sync Cloud Save.', 'info');
                            gameState = loadLocalGame();
                            gameState.isReady = true;
                            renderGame();
                        }
                        setupChatListener(); 

                    } else {
                        // User signed out
                        isAuthReady = true;
                        stopOnlineListener();
                        userId = null; 
                        
                        gameState = loadLocalGame();
                        gameState.isReady = true;
                        renderGame();
                        updateAuthButton(user);
                        
                        currentMode = 'local';
                        document.getElementById('mode-switch-button').textContent = 'Mode: Local üè†';
                        document.getElementById('mode-status-display').textContent = 'Mode: Local Browser Save';
                        log('Signed out. Switched to Local Mode (offline save).', 'info');
                    }
                    updateUsernameButtonState(); // Update username UI based on userId presence
                });
            } catch (e) {
                log(`Firebase initialization error: ${e.message}`, 'error');
                gameState = loadLocalGame();
                renderGame();
            }
        }
        // --- End Auth/Startup Functions ---

        // --- Game Logic (Modified to call generic saveGame) ---
        
        window.plant = function() {
            if (!gameState.isReady) return;
            if (gameState.seeds >= 1 && gameState.plots.length < gameState.plotCapacity) {
                gameState.seeds--;
                gameState.plots.push({ id: Math.random().toString(36).substring(2, 9), plantedAt: Date.now(), isReady: false });
                log('Planted 1 plot. Growth cycle started (10s).', 'info');
                saveGame(gameState);
            } else if (gameState.seeds === 0) {
                showModal('Not enough Seeds! Refill water to grow more seeds.');
            } else {
                showModal('Plot Capacity Reached! Buy Expand Farmland upgrades.');
            }
            renderGame();
        }

        window.water = function() {
            if (!gameState.isReady) return;
            if (gameState.money >= WATER_REFILL_COST) {
                gameState.money -= WATER_REFILL_COST;
                gameState.seeds += 10;
                log(`Refilled water for $${WATER_REFILL_COST}. Gained 10 Seeds.`, 'success');
                saveGame(gameState);
            } else {
                showModal(`Not enough money! Need $${WATER_REFILL_COST.toFixed(2)} to refill water.`);
            }
            renderGame();
        }

        window.harvest = function() {
            if (!gameState.isReady) return;

            const readyPlots = gameState.plots.filter(p => p.isReady).sort((a,b) => a.plantedAt - b.plantedAt);

            if (readyPlots.length > 0) {
                const plotToHarvest = readyPlots[0];
                const harvestIndex = gameState.plots.findIndex(p => p.id === plotToHarvest.id);
                const yieldAmount = 1.0 * gameState.harvestMultiplier;
                gameState.money += yieldAmount;
                gameState.plots.splice(harvestIndex, 1);
                log(`Harvested +$${yieldAmount.toFixed(2)} (Tier x${gameState.harvestMultiplier.toFixed(1)}).`, 'success');
                saveGame(gameState);
            } else {
                showModal('No plots ready to harvest! Wait for planted plots to mature (10s).');
            }
            renderGame();
        }

        window.buyUpgrade = function(key) {
            if (!gameState.isReady) return;
            const cost = getUpgradeCost(key);
            const upgrade = UPGRADES[key];

            if (key === 'plot_cap' && gameState.plotCapacity >= MAX_PLOT_CAPACITY) {
                showModal(`You have reached the maximum plot capacity of ${MAX_PLOT_CAPACITY}!`);
                return;
            }

            if (gameState.money >= cost) {
                gameState.money -= cost;
                upgrade.apply(gameState);
                gameState[key]++;
                log(`Purchased ${upgrade.name} (Lvl ${gameState[key]}) for $${cost.toFixed(2)}.`, 'purchase');
                saveGame(gameState);
            } else {
                showModal(`Not enough money! Need $${cost.toFixed(2)} to buy ${upgrade.name}.`);
            }
            renderGame();
        }

        // --- Render and Game Tick ---
        function renderUpgrades() { /* ... (same as before) ... */ }
        function renderFarmPlots() { /* ... (same as before) ... */ }

        function renderUpgrades() {
            const container = document.getElementById('upgrades-container');
            container.innerHTML = '';

            for (const key in UPGRADES) {
                const upgrade = UPGRADES[key];
                const currentLevel = gameState[key] || 0;
                const cost = getUpgradeCost(key);
                let disabled = gameState.money < cost;
                let buttonText = `Buy ($${cost.toFixed(2)})`;
                let isMaxed = false;

                if (key === 'plot_cap' && gameState.plotCapacity >= MAX_PLOT_CAPACITY) {
                    disabled = true;
                    buttonText = 'MAXED';
                    isMaxed = true;
                }

                let tierDisplay = '';
                if (key === 'harvest_multi') {
                    tierDisplay = ` (Current Yield: x${gameState.harvestMultiplier.toFixed(1)})`;
                }

                const cardHtml = `
                    <div class="card bg-white p-4 rounded-xl flex justify-between items-center shadow-md">
                        <div class="flex-grow">
                            <h3 class="font-bold text-gray-800">${upgrade.name} (Lvl ${currentLevel})${tierDisplay}</h3>
                            <p class="text-xs text-gray-500">${upgrade.effect}</p>
                        </div>
                        <button onclick="buyUpgrade('${key}')" ${disabled ? 'disabled' : ''}
                            class="ml-4 px-4 py-2 rounded-lg ${isMaxed ? 'bg-gray-500' : 'bg-purple-500 hover:bg-purple-600'} text-white font-semibold transition disabled:bg-gray-400 disabled:cursor-not-allowed flex-shrink-0">
                            ${buttonText}
                        </button>
                    </div>
                `;
                container.innerHTML += cardHtml;
            }
        }

        function renderFarmPlots() {
            const container = document.getElementById('farm-plots-container');
            container.innerHTML = '';
            const now = Date.now();

            document.getElementById('plots-count-display').textContent = gameState.plots.length;
            document.getElementById('plot-capacity-display-farm').textContent = gameState.plotCapacity;

            gameState.plots.forEach(plot => {
                const plotElement = document.createElement('div');
                plotElement.classList.add('farm-plot');

                if (plot.isReady) {
                    plotElement.classList.add('ready');
                    plotElement.innerHTML = 'ü•ï';
                } else {
                    plotElement.classList.add('growing');
                    plotElement.innerHTML = 'üå±';
                    const timeRemaining = Math.max(0, GROWTH_TIME_SECONDS - Math.floor((now - plot.plantedAt) / 1000));
                    plotElement.innerHTML += `<span class="plot-timer">${timeRemaining}s</span>`;
                }
                container.appendChild(plotElement);
            });

            const emptyPlotsCount = gameState.plotCapacity - gameState.plots.length;
            for (let i = 0; i < emptyPlotsCount; i++) {
                const emptyPlotElement = document.createElement('div');
                emptyPlotElement.classList.add('farm-plot', 'empty');
                emptyPlotElement.innerHTML = 'üåæ';
                container.appendChild(emptyPlotElement);
            }
        }


        function renderGame() {
            if (!gameState.isReady) return;

            const plotsReady = gameState.plots.filter(p => p.isReady).length;

            document.getElementById('money-display').textContent = gameState.money.toFixed(2);
            document.getElementById('seeds-display').textContent = gameState.seeds;

            document.getElementById('plant-btn').disabled = gameState.seeds < 1 || gameState.plots.length >= gameState.plotCapacity;
            document.getElementById('harvest-btn').disabled = plotsReady < 1;

            renderUpgrades();
            renderFarmPlots();
        }


        let autoPlantTimer = 0;
        let autoHarvestTimer = 0;

        function autoTick() {
            if (!gameState.isReady) return;

            const now = Date.now();
            let actionTaken = false;

            // 1. Plot Growth Check (Always run)
            const maturedCount = growPlots(gameState, now);
            if (maturedCount > 0) { actionTaken = true; }
            
            // 2. Update UI elements that rely on timers/cooldowns
            updateUsernameButtonState();
            
            // 3. Auto Upgrades Check
            autoPlantTimer++;
            autoHarvestTimer++;

            // Auto Plant (1 seed planted per 5s per level)
            if (gameState.autoPlantLevel > 0 && autoPlantTimer >= 5) {
                for (let i = 0; i < gameState.autoPlantLevel; i++) {
                    if (gameState.seeds >= 1 && gameState.plots.length < gameState.plotCapacity) {
                        gameState.seeds--;
                        gameState.plots.push({ id: Math.random().toString(36).substring(2, 9), plantedAt: now, isReady: false });
                        actionTaken = true;
                    }
                }
                autoPlantTimer = 0;
            }

            // Auto Harvest (1 plot harvested per 5s per level)
            if (gameState.autoHarvestLevel > 0 && autoHarvestTimer >= 5) {
                for (let i = 0; i < gameState.autoHarvestLevel; i++) {
                    const readyPlots = gameState.plots.filter(p => p.isReady).sort((a,b) => a.plantedAt - b.plantedAt);
                    if (readyPlots.length > 0) {
                        const plotToHarvest = readyPlots[0];
                        const harvestIndex = gameState.plots.findIndex(p => p.id === plotToHarvest.id);
                        if (harvestIndex !== -1) {
                            const yieldAmount = 1.0 * gameState.harvestMultiplier;
                            gameState.money += yieldAmount;
                            gameState.plots.splice(harvestIndex, 1);
                            actionTaken = true;
                        }
                    }
                }
                autoHarvestTimer = 0;
            }

            // 4. Save state if any automated action occurred (only for Local mode, Online sync is handled by listener/saveGame action)
            if (actionTaken && currentMode === 'local') {
                saveGame(gameState);
            }
            renderGame();
        }


        // --- Chat Functions (Unchanged) ---
        function setupChatListener() {
            const chatRef = getChatCollectionRef();
            if (!chatRef) { log('Error: Chat collection reference missing.', 'error'); return; }

            const q = firebase.query(chatRef, firebase.orderBy('timestamp', 'desc'), firebase.limit(50));

            firebase.onSnapshot(q, (snapshot) => {
                const chatContainer = document.getElementById('chat-container');
                chatContainer.innerHTML = ''; 

                const messages = [];
                snapshot.forEach(doc => { messages.push(doc.data()); });
                messages.reverse();

                messages.forEach(msg => {
                    const msgElement = document.createElement('div');
                    const isCurrentUser = msg.userId === userId; 
                    const messageClass = isCurrentUser ? 'bg-green-300 self-end rounded-lg p-2 max-w-[80%]' : 'bg-white self-start rounded-lg p-2 max-w-[80%] border border-gray-200';
                    const userDisplay = msg.displayUserId || 'Unknown';
                    const userColor = isCurrentUser ? 'text-green-800' : 'text-gray-600';

                    msgElement.className = `flex flex-col ${messageClass} shadow-sm`;
                    msgElement.innerHTML = `
                        <span class="text-xs font-bold ${userColor}">${userDisplay}</span>
                        <span class="text-sm text-gray-900 break-words">${msg.message}</span>
                    `;
                    chatContainer.prepend(msgElement);
                });
                
                if (messages.length === 0) {
                    chatContainer.innerHTML = '<div class="text-gray-400 text-center text-sm">Welcome to the Global Chat!</div>';
                }
            }, (error) => {
                log(`Error listening to chat: ${error.message}`, 'error');
            });
        }

        window.handleSendMessage = function() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!isAuthReady || !db || !userId) {
                showModal('Chat is not ready. Please wait for the game to fully load.');
                return;
            }

            if (message.length > 0) {
                const chatRef = getChatCollectionRef();
                if (chatRef) {
                    firebase.addDoc(chatRef, {
                        userId: userId,
                        displayUserId: displayUserId, 
                        message: message,
                        timestamp: firebase.Timestamp.now()
                    }).then(() => {
                        input.value = '';
                    }).catch(e => {
                        log(`Error sending message: ${e.message}`, 'error');
                    });
                }
            } else {
                showModal('Please enter a message before sending.');
            }
        }
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && document.getElementById('chat-input') === document.activeElement) {
                handleSendMessage();
            }
        });
        // --- End Chat Functions ---


        // Initialize the game
        window.onload = function() {
            initializeFirebase();
            // Start the game loop (1 second tick)
            setInterval(autoTick, 1000);
        };
    </script>
</body>
</html>
